 import * as React from "react" import * as ReactDOM from "react-dom/client" import * as Framer from "framer" const routes = {augiA20Il: {elements: {bj_yV4awM: "faq", c2ZynsCbs: "services", JYlfXrHUn: "about"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/KghwLxStA5NhsKk30DUD/M33LmMNleFoIMDYkxTsP/augiA20Il.js")),
path: "/"}, Q3wAu590R: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/ai4z3EQr8ngwvUlCgcwL/mY7x4nbIHEnsd5NRrueH/Q3wAu590R.js")), path: "/audit.html"}, FO7Dp2THB: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/0vGk1Dh4lIp4NrVlt3uI/HkSLaqKmcUphfH42JX32/FO7Dp2THB.js")),
path: "/education.html"}, Q60EptuPo: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/rv9AjENqlXVfBwST1waw/OVmrp8rsAhVImAeoNLqv/Q60EptuPo.js")), path: "/form.html"}, NQh7qvjFO: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/5FhWmYzuIGG89OLf40G9/RyjslNaQRRk40QFb6czP/NQh7qvjFO.js")),
path: "/blog"}, V892wiXun: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/fNHcdYA0yc4IDBh02kvd/kYn8PHYaNkmtWksDufgz/V892wiXun.js")), path: "/404"}, ycndO5432: {collectionId: "Xd1J0o8me", elements: {}, page: Framer.lazy(()
=> import("https://framerusercontent.com/modules/5KISg9y6CiajWh8rAUU9/MDnkzRWm57GgvkRsexfb/ycndO5432.js")), path: "/blog/:RyNA95by4"}} const locales = [{code: "en-US", id: "default", name: "English", slug: ""}] export async function getPageRoot({ routeId,
pathVariables, localeId }) { // We don't want the initial render to immediately have to suspend. await routes[routeId].page.preload() const content = React.createElement( Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes, collectionUtils:
{Xd1J0o8me: async () => (await import("https://framerusercontent.com/modules/xu7juYz6E2bW3DEtSGnG/syMxZKEnthwL3kij2NEa/Xd1J0o8me.js"))?.["utils"]}, framerSiteId: "b523f3691068bd5b70437ca21e35bcd4e3faeccbf10e5f5991927e14ae68f706", notFoundPage: Framer.lazy(()
=> import("https://framerusercontent.com/modules/fNHcdYA0yc4IDBh02kvd/kYn8PHYaNkmtWksDufgz/V892wiXun.js")), isReducedMotion: undefined, localeId, locales, preserveQueryParams: undefined, } ) const contentWithFeaturesContext = React.createElement( Framer.LibraryFeaturesProvider,
{ children: content, value: {enableAsyncURLUpdates: false, useGranularSuspense: false} } ) const page = React.createElement(Framer.PageEffectsProvider, { children: contentWithFeaturesContext, value: {global: {enter: {mask: {angle: 0, type: "wipe", width:
"100%"}, opacity: 1, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition: {damping: 30, delay: 0, duration: 0.4, ease: [0.27, 0, 0.51, 1], mass: 1, stiffness: 400, type: "tween"}, x: "0px", y: "0px"}}, routes: {}} }) return page }
const isBrowser = typeof document !== "undefined" if (isBrowser) { window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "'
+ exportIdentifier + '" in "' + packageAndFilename + '"' }) } // A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it window.process = { ...window.process, env: { ...(window.process ? window.process.env:
undefined), NODE_ENV: "production" } } // Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() window.__framer_events = window.__framer_events || [] } function track() { if (!isBrowser) return window.__framer_events.push(arguments)
} function callWhenDOMReady(callback) { if (!isBrowser) return if (document.readyState === "interactive" || document.readyState === "complete") { callback() } else { // Note that we’re listening to readystatechange instead of DOMContentLoaded because
the latter // doesn’t accurately reflect when the DOM is ready. Specifically, it’s delayed by scripts with // a defer attribute. document.addEventListener("readystatechange", () => { if (document.readyState === "interactive") callback() }) } } callWhenDOMReady(async
function() { try { const container = document.getElementById("main") let routeId, localeId, pathVariables, breakpoints, shouldHydrate = false if ("framerHydrateV2" in container.dataset) { const routeData = JSON.parse(container.dataset.framerHydrateV2)
routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables breakpoints = routeData.breakpoints shouldHydrate = true } else { const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname),
true, locales) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables } const page = await getPageRoot({ routeId, localeId, pathVariables }) function handleRecoverableError(error, errorInfo) { const componentStack
= errorInfo?.componentStack console.warn("Recoverable error during hydration. Please check any custom code or code overrides to fix server/client mismatches.", error, componentStack) // we only want to collect 1%, because this can be quite noisy (floods
the data pipeline) if (Math.random() > 0.01) return track("published_site_load_recoverable_error", { message: String(error), componentStack, // componentStack is more useful stack: componentStack ? undefined : error instanceof Error && typeof error.stack
=== "string" ? error.stack : null, }) } if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints", () => { Framer.removeHiddenBreakpointLayersV2(breakpoints) window.__framer_onRewriteBreakpoints?.(breakpoints) }) React.startTransition(()
=> { Framer.markHydrationStart() Framer.setInitialHydrationState() if (true) Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleRecoverableError }) }) } else { ReactDOM.createRoot(container, { onRecoverableError:
handleRecoverableError }).render(page) } } catch (error) { track("published_site_load_error", { message: String(error), stack: error instanceof Error && typeof error.stack === "string" ? error.stack : null }) throw error } }) callWhenDOMReady(async function
() { const { default: Badge } = await import("__framer-badge") const ContainerWithStyleAppearEffect = Framer.withStyleAppearEffect(Framer.Container) React.startTransition(() => { ReactDOM.createRoot(document.getElementById("__framer-badge-container"))
.render(React.createElement(ContainerWithStyleAppearEffect, { className: "__framer-badge", __framer__threshold: 0.5, __framer__animateOnce: true, __framer__opacity: 0, __framer__targetOpacity: 1, __framer__rotate: 0, __framer__x: 0, __framer__y: 10, __framer__scale:
1, __framer__transition: { "type": "spring", "ease": [0.44, 0, 0.56, 1], "duration": 0.3, "delay": 1, "stiffness": 350, "damping": 40, "mass": 1.5 }, __framer__rotateX: 0, __framer__rotateY: 0, __framer__perspective: 1200, }, React.createElement(Badge)))
}) })