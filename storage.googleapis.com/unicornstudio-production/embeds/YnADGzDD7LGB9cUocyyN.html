{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;const vec3 uColors[1] = vec3[]( vec3(1.000000, 1.000000, 1.000000) );uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0+0.025*a*(1.0-a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i < 1; i++) { float colorPosition = float(i) / float(1); float nextColorPosition = float(i + 1) / float(1); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(uColors[i]); vec3 linEnd = linear_from_srgb(uColors[i + 1]); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(uColors[1-1]); }vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * 3.14159265);vec4 color = vec4(0,0,0,1);float position; if(1 == 1) { color.rgb = uColors[0]; } else if (0 == 0) { position = (uv.x+0.5);} else if (0 == 1) { position = length(uv); } else if (0 == 2) { float angle = atan(uv.y, uv.x); float normalizedAngle = angle / (2.0 * 3.14159265359) + 0.5; float doubledAngle = 2.0 * normalizedAngle; doubledAngle = doubledAngle > 1. ? 2.0 - doubledAngle : doubledAngle; position = clamp(doubledAngle, 0.0, 1.0); } else if (0 == 3) { } if(1 > 1) { position -= (uTime*0.01 + 0.00); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? animatedPos - 1./float(1) : animatedPos - 1./float(1);color.rgb = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color.rgb += dither; }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{}},{"local":{"id":"781083b9-4c36-40a5-a82c-48864e3eedcf","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1.6,"isElement":true,"opacity":1,"displace":0.4,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":1,"dispersion":1,"axisTilt":0.49,"layerType":"shape","borderRadius":0,"coords":[[0,0],[699,0],[699,442],[0,442]],"effects":[],"fill":["#FFFFFF"],"gradientAngle":0,"gradientType":"linear","mask":0,"rotation":0,"translateX":-3,"translateY":-4,"type":"rectangle","numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }const float STEPS = 24.0; const float PI = 3.1415926;vec3 refrakt(vec3 eyeVector, vec3 normal, float iorRatio) { float dotProduct = dot(eyeVector, normal); float k = 1.0 - iorRatio * iorRatio * (1.0 - dotProduct * dotProduct); if (k < 0.0) { return reflect(eyeVector, normal); } else { return iorRatio * eyeVector - (iorRatio * dotProduct + sqrt(k)) * normal; } }vec4 displacement (vec2 st, vec4 bg, vec4 color) { if(1.00 == 1.0) { vec2 refraction = refrakt(vec3(vTextureCoord, 0.5), color.rgb, 0.40-0.5).xy; vec2 displaced = vTextureCoord + mix(vec2(0), refraction * 0.1, 0.40); vec4 bgDisp = texture(uBgTexture, displaced); bgDisp.rgb = bgDisp.rgb; return bgDisp * color.a; } else { vec2 normal = vec2(bg.r * 2.0 - 1.0, bg.g * 2.0 - 1.0) * 0.1; if(0.00 == 1.) { return texture(uMaskTexture, st + normal * 0.40) * texture(uTexture, st + normal * 0.40).a; } else { return texture(uTexture, st + normal * 0.40); } } }vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.49); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 maskColor = texture(uMaskTexture, vTextureCoord); vec4 background = uSampleBg == 1 ? texture(uBgTexture, vTextureCoord) : vec4(0); vec4 color = texture(uTexture, uv);if (0.00 == 1.) { color = maskColor * color.a; }if (0.40 > 0.) { if(0.00 == 1.) { color = displacement(uv, background, maskColor); } else { color = displacement(uv, background, color); } }if (0 > 0) { color.rgb = blend(0, color.rgb, background.rgb); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","mouseMomentum":0.47,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_abberation(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }const float ITERATIONS = 25.;vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float zMix = strength; vec2 distorted = mouseDir * 0.4 * 0.50; color = texture(uTexture, uv - distorted); color.rgb = chromatic_abberation(color.rgb, uv - distorted, distorted * 1.00*0.12); color = mix(vec4(vec3(0, 0, 0), 0.00), color, zMix); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x/uResolution.y;return revealTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec3 mouseRgb = texture(uPingPongTexture, uv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.69 * 2.); vec2 direction = vec2(cos(angle * 2. * PI), sin(angle * 2. * PI)); vec2 mouseDir = direction * strength; vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * 2. * PI); float amplitude = 0.003; for(float i = 1.0; i <= 5.0; i++) { st = st * rot(i/5. * PI * 2.); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(angle * -1. * 2. * PI); st.x /= aspectRatio; return st; }const float TWOPI = 6.2831852; const float edgeSoftness = 0.75; void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0); vec2 dir = uMousePos * vec2(aspectRatio, 1.0) - uPreviousMousePos * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir); float rad = 0.10 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); angle += angle < 0.0 ? TWOPI : 0.0; uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.56); float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint); float s = smoothstep(rad, rad * 0.30, distanceToLine) * smoothstep(0.0, dist, length(closestPoint - uPreviousMousePos * vec2(aspectRatio, 1.0)));vec3 color = vec3(0.8333, 1.0, 1.0); color.x = angle / TWOPI; vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.09)).rgb;vec3 draw = mix(lastFrameColor, mouseColor, dist * s);fragColor = vec4(draw * pow(0.73, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI = 3.1415926;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_abberation(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }float Gaussian(float x, float sigma) { return exp(-x * x / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma); }vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }const float ITERATIONS = 25.;vec4 blurTrail (vec2 uv, vec2 mouseDir) { vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0);for(float i = -ITERATIONS; i <= ITERATIONS; i++) { float scale = 0.0001 + 0.50 * 0.5; float weight = Gaussian(i/ITERATIONS, scale); vec2 offset = distorted * (1.5+scale) * mix(1., i / ITERATIONS, scale); vec4 samp = texture(uTexture, uv - offset); samp.rgb = chromatic_abberation(samp.rgb, uv - offset, offset*1.00*0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x/uResolution.y;return blurTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec3 mouseRgb = texture(uPingPongTexture, uv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.58 * 2.); vec2 direction = vec2(cos(angle * 2. * PI), sin(angle * 2. * PI)); vec2 mouseDir = direction * strength; vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * 2. * PI); float amplitude = 0.003; for(float i = 1.0; i <= 5.0; i++) { st = st * rot(i/5. * PI * 2.); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(angle * -1. * 2. * PI); st.x /= aspectRatio; return st; }const float TWOPI = 6.2831852; const float edgeSoftness = 0.75; void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0); vec2 dir = uMousePos * vec2(aspectRatio, 1.0) - uPreviousMousePos * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir); float rad = 0.10 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); angle += angle < 0.0 ? TWOPI : 0.0; uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.00); float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint); float s = smoothstep(rad, rad * 0.80, distanceToLine) * smoothstep(0.0, dist, length(closestPoint - uPreviousMousePos * vec2(aspectRatio, 1.0)));vec3 color = vec3(0.8333, 1.0, 1.0); color.x = angle / TWOPI; vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.00)).rgb;vec3 draw = mix(lastFrameColor, mouseColor, dist * s);fragColor = vec4(draw * pow(0.50, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI = 3.1415926;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"diffuse","speed":0.25,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform float xy;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float MAX_ITERATIONS = 24.; const float PI = 3.14159265; const float TWOPI = 6.2831853;float random(vec2 seed) { seed.x *= uResolution.x/uResolution.y; return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float aspectRatio = uResolution.x/uResolution.y; float delta = fract(floor(uTime)/20.); float angle, rotation, amp; float inner = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); float outer = max(0., 1.-distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)));if(0.08 == 0.) { fragColor = texture(uTexture, uv); return; }float amount = 0.08 * ease(0, mix(inner, outer, 0.50)) * 2.;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); pos = vec2(0.5, 0.5); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(dist < distance(uv, mPos)) { vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}amount *= dist;vec4 result = vec4(0); float threshold = max(1. - 0.50, 2./MAX_ITERATIONS);for(float i = 1.; i <= MAX_ITERATIONS; i++) { float th = i/MAX_ITERATIONS; if(th > threshold) break;vec2 ranPoint = vec2( random(uv + th) * 2. - 1., random(uv + th * 2.) * 2. - 1. ) * mix(1., random(uv + th * 3.), 0.8); vec2 offset = ranPoint * vec2(0.50, 1.-0.50) * amount * 0.4; offset.x /= aspectRatio; result += texture(uTexture, uv + offset); }result /= floor(MAX_ITERATIONS * threshold);vec4 col =result; if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = col * (maskColor.a * maskColor.a); } else { fragColor = col; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"sine","speed":0.04,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition; uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 wave = vVertexPosition.xy * 0.5 + 0.5; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00))); uv = mix(uv, wave, dist);vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float; in vec3 aVertexPosition; in vec2 aTextureCoord; uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;uniform float uTime; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; vec2 rotateUV(vec2 uv, float rotation) { float mid = 0.5; return vec2( cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid, cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid ); }const float PI = 3.141592;void main() { vec3 vertexPosition = aVertexPosition; vec2 waveCoord = vec2(vertexPosition.xy); float angle = (0.00 * 360.) * 3.1415926 / 180.; float thirdPI = PI * 0.3333; float time = uTime*0.25; float frequency = 20.0 * 0.50; float dist = 1.-distance(vec2(0.5, 0.5), aTextureCoord); dist = max(0., dist); float amp = 0.38 * 0.2;float waveX = sin((waveCoord.y + vec2(0.5, 0.5).y) * frequency + (time * thirdPI)) * amp; float waveY = sin((waveCoord.x - vec2(0.5, 0.5).x) * frequency + (time * thirdPI)) * amp; waveCoord.xy += vec2(mix(waveX, 0., 0.00), mix(0., waveY, 0.00));if(vertexPosition.x == 1.) { waveCoord.x = 1.; } if(vertexPosition.x == -1.) { waveCoord.x = -1.; } if(vertexPosition.y == 1.) { waveCoord.y = 1.; } if(vertexPosition.y == -1.) { waveCoord.y = -1.; }gl_Position = uPMatrix * uMVMatrix * vec4(vec3(aVertexPosition), 1.0);vTextureCoord = aTextureCoord; vertexPosition.xy = waveCoord; vVertexPosition = vertexPosition; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uDecay; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 100.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 coord) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(coord * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); float blueNoiseSample = blueNoise.r; return mod((blueNoiseSample * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.84)) * 0.0078; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float blueNoiseOffset = getBlueNoiseOffset(st) * 0.84;for (float i = 0.0; i <= MAX_ITERATIONS; i++) { float x = min(0.999, i * offset); x += blueNoiseOffset * 0.004; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(blueNoiseOffset), sin(blueNoiseOffset)) * 0.001; color += texture(uTexture, marchPos).rgb * weight; weight *= decay; } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.20 - 0.1, 0.20, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 5.); color.a = bg.a + color.r; } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uDecay; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 100.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 coord) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(coord * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); float blueNoiseSample = blueNoise.r; return mod((blueNoiseSample * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.84)) * 0.0078; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float blueNoiseOffset = getBlueNoiseOffset(st) * 0.84;for (float i = 0.0; i <= MAX_ITERATIONS; i++) { float x = min(0.999, i * offset); x += blueNoiseOffset * 0.004; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(blueNoiseOffset), sin(blueNoiseOffset)) * 0.001; color += texture(uTexture, marchPos).rgb * weight; weight *= decay; } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.20 - 0.1, 0.20, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 5.); color.a = bg.a + color.r; } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blinds","speed":0.05,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float STEPS = 10.0;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec3 chromatic_abberation(vec2 st, vec2 aberrated) { vec4 red = vec4(0); vec4 blue = vec4(0); vec4 green = vec4(0);float invSteps = 1.0 / STEPS; float invStepsHalf = invSteps * 0.5;for(float i = 1.0; i <= STEPS; i++) { vec2 offset = aberrated * (i * invSteps); red += texture(uTexture, st - offset) * invSteps; blue += texture(uTexture, st + offset) * invSteps; green += texture(uTexture, st - offset * 0.5) * invStepsHalf; green += texture(uTexture, st + offset * 0.5) * invStepsHalf; }return vec3(red.r, green.g, blue.b); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st, float aspectRatio) { return st * vec2(1.0/aspectRatio, 1.0); }vec2 rotate(vec2 st, float angle) { float s = sin(angle); float c = cos(angle); mat2 rot = mat2(c, -s, s, c); return rot * st; }vec4 blinds(vec2 st, float mDist) { float aspectRatio = uResolution.x/uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00) * floor(1.00); pos = scaleAspect(pos, aspectRatio); st = scaleAspect(st, aspectRatio); st = rotate(st - pos, -0.11 * 2.0 * PI) + pos;vec3 distort = vec3(0); float divisions = 2. + 0.50 * 30.; float dist = 0.33 * 4. + 1.; float segment = 0.;float amount = 1.00 * mDist;vec3 first = vec3(1,0,0); vec3 second = vec3(0,1,0); vec3 third = vec3(0,0,1); if(0 == 0) { segment = fract((st.y + 1. - pos.y - 1. + uTime*0.01) * divisions); distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.y -= pow(distort.r, dist)/10. * amount; st.y += pow(distort.b, dist)/10. * amount; } else if(0 == 1) { segment = fract((st.x + 1. - pos.x - 1. + uTime*0.01) * divisions); distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.x -= pow(distort.r, dist)/10. * amount; st.x += pow(distort.b, dist)/10. * amount; } else if(0 == 2) { segment = fract((st.x + 1. - pos.x - 1. + uTime*0.01) * divisions); distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.x -= pow(distort.r, dist)/10. * amount; st.x += pow(distort.b, dist)/10. * amount;segment = fract((st.y + 1. - pos.y - 1. + uTime*0.01) * divisions); distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.y -= pow(distort.r, dist)/10. * amount; st.y += pow(distort.b, dist)/10. * amount; } else if(0 == 3) { vec2 diff = st - pos; float angle = atan(diff.y, diff.x); segment = fract((angle + uTime*0.01 + PI) / (2. * PI) * divisions);distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -= pow(distort.r, dist)/10. * amount * normalize(diff); st += pow(distort.b, dist)/10. * amount * normalize(diff); } else if(0 == 4) { vec2 diff = st - pos; float radius = length(diff); segment = fract(radius * divisions - uTime*0.01);distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -= pow(distort.r, dist)/10. * amount * normalize(diff); st += pow(distort.b, dist)/10. * amount * normalize(diff); } else if(0 == 5) { vec2 diff = st - pos; float angle = -PI/4.; vec2 rotatedDiff = vec2( diff.x * cos(angle) - diff.y * sin(angle), diff.x * sin(angle) + diff.y * cos(angle) );float manhattanDist = abs(rotatedDiff.x) + abs(rotatedDiff.y); segment = fract(manhattanDist * divisions - uTime*0.01); distort = mix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -= pow(distort.r, dist)/10. * amount * normalize(diff); st += pow(distort.b, dist)/10. * amount * normalize(diff); }st = rot(0.11 * 2. * PI) * (st - pos) + pos; st = unscaleAspect(st, aspectRatio); vec4 col = texture(uTexture, st);if(0.00 > 0.) { vec2 offset = vec2(pow(distort.r, dist), pow(distort.b, dist)) * vec2(0.1) * amount * 0.33; col.rgb = chromatic_abberation(st, offset * 0.00); } return col; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(mDist < distance(uv, mPos)) { vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}vec4 col = blinds(uv, mDist); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = col * (maskColor.a * maskColor.a); } else { fragColor = col; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{}}],"options":{"name":"Liquid Chroma","fps":60,"dpi":2,"scale":1},"version":"1.2.4"}